8월 18일 심화교육 Day 1

1. Gameplay Framework, 엔진 지원 네트워크를 중요하게 생각하자.

2. 레벨을 제일 먼저 만들자. 
GameModeBase를 만들자.
월드 세팅
Pawn 생성

3. Construction Scrip : 생성자 대용임

4, 고해상도 시간

5. 변수의 디테일에서 값의 범위를 설정할 수 있다.

6. Delay : 정해놓은 시간동안 딜레이 후 실행한다. 시간이 지나가기 전에 입력이 한번 더 들어와도
처음 해놓은 시간이 다 지나고 실행한다.

7. 시퀀스는 0번 핀의 일이 끝나는건 기다리지 않고 일단 다음 핀을 실행한다.

8. 스프링암의 렉을 줄 수 있다. 움직임이 부드럽게 보인다.
카메라 콜리전 : 카메라와 플레이어 사이에 벽같은게 있으면 캐릭터에 가까워지며 찍는다.

9. projectilemovement의 디테일에 초기속도, 중력값등을 조절할 수 있다.
발사체 이동을 짜지 않아도 그냥 앞으로 나간다. 미리 설정되어 있다.



8.19 Day2
1. mesh에도 콜리전이 있는데 box콜리전같은 단순화된 걸 쓰는 이유는 연산량을 줄이기 위해서

2. 블프의 스태틱매시컴포넌트의 디테일에 콜리전항목의 기능들은 단순콜리전으로 쓴다.

3. overlap을 하면 generate Overlap Events를 체크해줘야 한다.
충돌하는 양쪽 둘 다 체크가 되어있어야 한다. 한쪽이 안되있으면 충돌하지 않음

4. 사운드는 웨이브와 큐가 있는데 웨이브는 그냥 소리고 큐는 웨이브로 편집을 한것이다. 두개의 웨이브를
랜덤으로 재생한다던지 하는 편집이 가능함

5. 스카이 라이트 : 하늘색 입혀줌

6. 머티리얼에서 월드 포지션 오프셋은 RGB로 위치를 움직이게 하는데 그리는건 쉐이더고 GPU가 그리기 때문에
CPU에서 계산을 안해도 된다. 배경의 풀같은거를 움직이게 할 때 쓴다. 파라미터로 바꾸면 CPU가 계산한다.
SimpleGrassWind 노드로 풀움직이는 듯이 해준다.
엠비언트 오클루전 : 빛이 없으므로 까맣게 칠하라고 하는것 ex) 코밑의 콧구멍

7. 머티리얼을 그리는 GPU는 명령을 쓸수있는게 한정되서 안쓰는 노드는 정리를 해줘야한다.

8. 콜리전이 충돌해서 BeginOverlap이벤트가 실행하는데 로켓이 Destroy되버리면 Target에서 로켓의 태그를
못 읽어온다. 그래서 delay를 조금 걸어준다. Target이 로켓의 태그를 읽는 시간을 벌어주기 위해서

9. 비주얼의 세팅을 C++로 설정하자.
툴의 import and export setting을 눌러서 no, no 였나 하다가 c++로 설정하자.
툴에 오른쪽 눌러서 커스텀 들어가고 커맨더에 툴바 스탠다드에 solution configurations를 키우자.

10. SHipping은 배포할때 하고 개발할때는 위에 4개를 쓴다. Development Editor로 하면 에디터로 나오고
dll로 나오고 Development로 하면 exe로 나와서 실행 파일이 생성된다. Development Editor로 개발하자.
Win64로 설정해서 사용해야 한다. 시작 프로젝트를 언리얼 프로젝트 이름으로 설정해야 한다.
아웃풋 창을 띄우때는 툴에 Projects and Solutions에 output창 띄우기

11. IWYU 레퍼런스 가이드를 찾아보자
헤더에 인클루드 하지 않는다. 인클루드 추가는 cpp에서

12. 디버거하면 에러난곳이 어딘지 나온다. 내 코드를 따라가면 어딘지 나온다.

13. RTTI : 실행중에 클래스가 뭔지 몇개 있는지 아는거임. 런타임 타입정보
unreal header tool이 컴파일해서 언리얼의 룰을 잘 따랐는지 검사한다.
필요한 것들을 알아서 빌드해준다. 언리얼이 미리 다 해놈.
리플렉션 코드를 만들어서 무튼 알아서 해준다.

14. new를 안해도 실행되는 이유 CDO가 있어서?



Day03 8.20
1. 엔진이 new같은 할당을 해준다. 가비지 컬렉션, 레퍼런스 업데이트를 해준다. 문서에 나옴

2. 프로퍼티의 종류를 알자

3. ConstructorHelpers를 생성자에서 쓰게되면 메쉬정보까지 전부 로딩을 해야하므로 추천하는 방법은 아니다.
컴퓨터가 느려짐. 굳이 쓴다면 static이라도 붙이자. 안붙이면 생성할 때마다 로드하기때문에 static으로 하나만두자.
BeginPlay에서 하면 꺼진다.

4. 블프의 체크박스들을 c++에서 다루고 싶다면 앞에 b를 쳐서 검색하자.
SpringArm->bEnableCameraLag 처럼 b가 붙는다.

5. deltaTime 가져오는법 
#include "Kismet/GameplayStatics.h" 하고 UGameplayStatics::GetWorldDeltaSeconds(GetWorld())로 쓴다.

6. 언리얼에서 쓸거면 UFunction를 붙이고 내부에서만 쓸거면 안붙여도 된다.

7. 컨트롤, 쉬프트, 스페이스 누르면 함수의 인자목록을 볼 수 있다.

8. 블프에서 쓴 함수를 cpp에서도 쓰고 싶은데 못 찾겠으면 노드를 컨트롤 c해서 메모장에 눌러보면
함수 이름을 알 수 있다. BlueprintGraph가 붙으면 cpp에서는 쓰기 안좋다.

9. 델리게이트 함수 만들때는 UFUNCTION()을 꼭 붙여야한다.

10. OnActorBeginOverlap을 보면 Two파라미터이다. 인자를 뒤에서부터 두개를 가져오면 된다.

11. 로켓같은거의 콜리전의 오버랩 체크는 자동으로 되어있다.

12. 컴포넌트같은걸 붙일 때 인클루드를 꼭 확인하자.

13. 애셋을 옮기고 싶을때 프로젝트의 content폴더에 넣으면 된다.



Day 04 08.21
1. 델리게이트 쓸때 UFUNCTION() 잊지 말자!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

2. 게임모드를 불러오고 쓸때는 null체크를 꼭하자. null이면 게임이 꺼져 버리니까

3. 서버에서 쌓는 방식으로 하는 작업 SVN. 서버가 다운되면 일을 못한다.
분산처리해서 하는게 git. 마스터 서버가 있고 내 컴에 서버를 복제해와서 올리고 복제 서버에서 마스터 서버에
올린다.

4. 에픽게임즈 홈페이지의 계정 연결에서 깃허브와 연결한다. 깃허브 에픽게임즈에 가면 볼 수 있다.
tortoisegit 다운해서 받음 설치중에 뭔 사이트 가서 다운받고 다음다음 눌러서 다운 받고 check누르고 다음다음
마침 누르면 폴더 오른쪽 누르면 git나온다.

5. 깃 허브에서 다운받을 코드 주소를 가져와서 Git Clone으로 받으면
다운 받아진다.

어딘가의 경로에 오른쪽 눌러서 저장소 만들고 파일을 Add한다. 커밋을 누르면 저장할 파일을 선택해서
커밋할 수 있다.
리부트를 누르면 최근에 저장한거를 복구할 수 있다.
쇼로그로 한것을 볼 수 있다.

cmd에서 cd 한칸 뛰고 저장되어있는 파일경로 쓴뒤에 깃허브에 저장? 푸쉬할 수 있는 커멘드를 복사하고
(...or push an existing repository from the command line에 있는 커멘드이다.)
cmd에 마우스 오른쪽 버튼 누르면 붙여넣기 된다. 그럼 알아서 올려준다.
git remote add origin https://github.com/joHyeok/First.git(깃 허브 주소)
컴퓨터의 git폴더에 깃 허브 주소의 오리진을 추가한다.

git push -u origin master
오리진에서 깃허브의 마스터로 push한다.

클론을 만들고 작업을 하고 새로운건 Add하고 Push한다. 받을려면 Pull한다.

CreateBrunch로 새로 만들고 brunch로 다른 버전으로 만들수 있다. 
스위치로 작업할 버전을 선택할 수 있다. 로그에 들어가서 버전을 오른쪽 버튼 눌러서 어떤 버전인지정할 수 있다.
혹은 switch로 바꿀수 있다.
빨간게 선택된거 일듯 아마도?
깃허브에 저장소를 지울려면 세팅에서 제일밑에 지우는거 클릭하고 그 진한 이름 그대로 입력하면 된다.

브런치 Push할 때 그 앞 master도 push하고 새로 만든 버전을 push해야 들어간다.

젠키스 같은애로 빌드 도와준다. 제대로 못들음. 알아볼것

6. 언리얼 깃 사용법
언리얼 폴더에서 클론을 만들고 포함시키지 않을 것을 ignore시키고 (Intermediate를 제외시킨다.)
구글에 gitignore.io에 들어가서 언리얼엔진을 검색한 후 나온 소스들을 ignore txt에 추가한 후 저장하자.
맵을 저장하고 커밋하고 push한다. 만드는 중간중간 커밋하자.

7. 물리적힘을 받을려면 피직스를 체크 콜리전에 있음 콜리전 프리셋을 PhysicsActor로 바꾸자
무게를 조절할 수 있다.

8. 스프링암에 카메라 설정의 Inherit를 끄면 카메라의 부모인 액터의 움직임과 상관없이 같은 자리에서 보여준다.

9. 월드상 앞방향은 makeVector로 x에 1을 넣으면 된다.

10. 다른사람꺼를 Fork하면 내 깃 허브에서 볼수 있다.



08.24
1. 월드세팅에서 떨어지는 높이에 따라 폰이 사라지게 할 수 있다. 킬 Z로 조정한다.

2. UFUNCTION(BlueprintCallabe) 하면 c++함수를 블프에서 쓸 수 있다.
UFNNCTION(BlueprintImplementableEvent) : cpp에서 호출하지만 작업은 블프에서 함
UFNNCTION(BlueprintNativeEvent) : cpp에서 호출하지만 작업은 블프에서 함 기본 구현 cpp가 있음
cpp에서 기본 구현을 정의해줘야 한다. 함수 이름에 _Implementation()를 붙여서 선언하고
정의도 해줘야한다. 블프에서 구현을 안해도 cpp의 기본 구현이 실행된다.



08.26
1. C++ Unmanaged Language 언어 메모리 관리 안함
UE C++ Managed Language  메모리 관리  내가안함 엔진이 함
Blueprint Managed Language  메모리 관리 내가 안함 엔진이 함

2. 엔진이 쓰는 모든건 UObject를 상속받는다.

3. c++에서 BlueprintImplementableEvent을 만들면 언리얼 헤더툴이 자동으로 만들어 주고 블프에서
호출이 된다. 구현은 블프에서 한다.

4. 스케일을 마야나 맥스에서 잘 맞춰서 줘야한다. 안그럼 나중에 힘듬

5. 스켈레톤, 메시, 애니메이션, 피직스, 또 하나 총 5개가 세트로 묶여있다.

6. cpp에서 바꿀 때 블프를 닫고 바꿔야한다. 안그럼 반영이 잘 안됨

7. GetCapsuleComponent()->GetScaledCapsuleHalfHeight(); : 캡슐컴포넌트의 절반길이를 Z축의 스케일값과
곱해서 반환함
GetCapsuleComponent()->GetUnScaledCapsuleHalfHeight(); : 그냥 절반길이만 반환함

8. 클래스 디폴트의  Pawn Use Controller Rotation을 쓰면 폰이 컨트롤러의 회전에 따라 같이 움직인다.
스프링 암의 Inherit Pitch를 체크하면 스프링암이 컨트롤러의 회전에 따라 움직인다
폰을 헤제하고 스프링 암을 체크하면 폰은 움직이지 않고 카메라만 움직이는 거 처럼 보인다.
CharacterMovement의 회전 로테이션을 사용하면 움직이는 방향으로 폰이 회전한다.

9. 회전 입력을 하면 PlayerController가 가져가고 
PlayerContoller의 절대회전을 pawn과 springarm, charatacermovement가 사용한다.

10. 폰의 이동과 애니메이션의 계산이 CPU와 GPU로 다르다. 그래서 블프랑 애님블프랑 따로 있는것임
매 업데이트마다 폰의 정보를 가져와서 애니메이션에서 사용할 정보를 업데이트
애님 그래프가 그 정보를 바탕으로 애니메이션 재생

11. 큐의 모듈레이터 : 소리를 편집한다. 볼륨이나 길이의 최소 최대를 정해서 넘어가면 자른다.